Question 3 : 

  Complexité et terminaison : 
  research est en O(mn), relocate fait appel à research puis réalise au plus m+n swaps, donc est en O(mn+m+n)=O(mn).
  Comme get_solution fait appel mn fois à relocate, elle est en O((mn)^2). Comme research, qui est appelée mn fois 
  réalise au plus m+n swaps, la longueur de la solution est mn*(m+n).

  Optimalité et terminaison :
  Comme l'algorithme replace successivement 1, ..., mn dans cet ordre, la fonction termine et donne une solution valide.
  Néanmoins, comme les opérations sur chacun des éléments 1, ..., mn sont indépendantes, dans le sens ou le déplacement 
  de i, lorsque 1, ..., i-1 sont déjà rangés, peut modifier les positions des éléments non encore rangés, elles ne cherchent 
  pas nécessairement à faire les déplacements les plus adéquats, tant que l'élément i arrive au bon endroit. Ainsi, un
  nombre important d'opérations ne sont pas exploitées, voire inutiles. On pourrait, pour améliorer l'algorithme, essayer 
  de décider, en fonction des swaps possibles pour permettre à i d'arriver au bon endroit, de choisir le déplacement qui
  aurait l'influence la plus positive sur les éléments non encore rangés.

  Remarque supplémentaire : 
  Une autre proposition d'algorithme, considérée comme "naïve" par le binôme est disponible également sous le nom de get_solution2
  dans la classe Solver. Cette propostion avait déjà été évoquée avec le chargé de TD, et donc ne fera pas l'objet de précisions
  supplémentaires, sauf demande du correcteur après le premier rendu. Notez seulement que get_solution donne une solution avec une
  meilleure complexité, en O(mn*(max(m+n))) selon nos calculs.

Question 7 : 

  Techniquement, construct_graphe a une complexité en O((n*m)!^3) car on fait un while (qui termine effectivement car il est toujours 
  possible de trouver une grille dans la liste des grilles qui est voisine à une des grilles du graphe) sur toutes les grilles possibles de taille n*m 
  (ce qui est donc en temps (n*m)!), puis on les parcourt toutes (temps en (n*m)!), puis on parcourt tous les noeuds du graphe (temps encore en (n*m)!).
  Le graphe construit a (n*m)! noeuds (qui correspondent aux grilles et donc aux permutations de l’ensemble {1,2,..., n*m}) et comme 
  c’est un arbre il a (n*m)-1 arêtes.
